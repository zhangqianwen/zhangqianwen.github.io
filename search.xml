<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Learning GDB]]></title>
      <url>/2017/08/03/Learning-GDB/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>记录GDB学习</p>
<h2 id="信息显示"><a href="#信息显示" class="headerlink" title="信息显示"></a>信息显示</h2><p><strong>版本信息</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">cheven@cheven-GL552JX:~$ gdb</div><div class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1</div><div class="line">Copyright (C) 2016 Free Software Foundation, Inc.</div><div class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</div><div class="line">This is free software: you are free to change and redistribute it.</div><div class="line">There is NO WARRANTY, to the extent permitted by law.  Type "show copying"</div><div class="line">and "show warranty" for details.</div><div class="line">This GDB was configured as "x86_64-linux-gnu".</div><div class="line">Type "show configuration" for configuration details.</div><div class="line">For bug reporting instructions, please see:</div><div class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</div><div class="line">Find the GDB manual and other documentation resources online at:</div><div class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</div><div class="line">For help, type "help".</div><div class="line">Type "apropos word" to search for commands related to "word".</div></pre></td></tr></table></figure></p>
<p><strong>启动时不显示相关信息</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cheven@cheven-GL552JX:~$ gdb -q</div></pre></td></tr></table></figure></p>
<p><strong>输出信息多时不暂停</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(gdb) set height 0</div></pre></td></tr></table></figure></p>
<p><strong>分析代码</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuru</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;arr[i]);</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> arr[<span class="number">10000</span>],</div><div class="line">    i=<span class="number">0</span>,m,n;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">    shuru(arr,n);</div><div class="line">    m=n<span class="number">-1</span>;</div><div class="line">    sort(arr,<span class="number">0</span>,m);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,arr[m/<span class="number">2</span>]);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i = low;</div><div class="line">    <span class="keyword">int</span> j = high;</div><div class="line">    <span class="keyword">int</span> temp = a[i];</div><div class="line">    <span class="keyword">if</span>( low &lt; high)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(i &lt; j)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">while</span>((a[j] &gt;= temp) &amp;&amp; (i &lt; j))</div><div class="line">            &#123;</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">            a[i] = a[j];</div><div class="line">            <span class="keyword">while</span>((a[i] &lt;= temp) &amp;&amp; (i &lt; j))</div><div class="line">            &#123;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            a[j]= a[i];</div><div class="line">        &#125;</div><div class="line">        a[i] = temp;</div><div class="line">        sort(a,low,i<span class="number">-1</span>);</div><div class="line">        sort(a,j+<span class="number">1</span>,high);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc test.c -o sample -g</div></pre></td></tr></table></figure>
<p>在上面的命令行中，使用 -o 参数指定了编译生成的可执行文件名为 sample，使用参数 -g 表示将源代码信息编译到可执行文件中。如果不使用参数 -g，会给后面的GDB调试造成不便。当然，如果我们没有程序的源代码，自然也无从使用 -g 参数，调试/跟踪时也只能是汇编代码级别的调试/跟踪。</p>
<p><strong>常用命令</strong></p>
<ul>
<li>加载文件</li>
</ul>
<p>直接进入gdb而未加载可执行文件，或者加载了目标文件，想换一个其他的——可以使用<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(gdb) file test2</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(gdb) exec(-file) test2</div></pre></td></tr></table></figure></p>
<ul>
<li><p>设置断点</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>&lt;rowNums...&gt;代表想要设立断点的行数</div><div class="line">(gdb)b(reakpoints) &lt;rowNums...&gt;</div><div class="line"></div><div class="line">(gdb) b func</div><div class="line">(gdb) b *func</div><div class="line"><span class="meta"></span></div><div class="line">#列表打印所有已设立的断点</div><div class="line">(gdb) info b(reakpoints)</div><div class="line"><span class="meta"></span></div><div class="line">#代表删除第Num个断点</div><div class="line">(gdb) d(elete) Num</div></pre></td></tr></table></figure>
</li>
<li><p>基本调试流程</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(gdb) r(un)</div><div class="line">(gdb) n(ext)</div><div class="line">(gdb) s(tep)</div><div class="line"><span class="meta">#</span>和其他调试相仿，这两条分别代表step over和step in，</div><div class="line"></div><div class="line">(gdb) c(ontinue)</div><div class="line"><span class="meta">#</span>run和continue功能其实差不多，都是继续往下运行，直到下一个断点停下来</div><div class="line"><span class="meta">#</span>run是开始运行前的启动命令，continue是运行中的命令。</div></pre></td></tr></table></figure>
</li>
<li><p>汇编</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>看汇编代码和执行过程，</div><div class="line">(gdb) ni</div><div class="line">(gdb) si</div><div class="line"><span class="meta"></span></div><div class="line">#显示汇编代码</div><div class="line">(gdb)layout asm</div></pre></td></tr></table></figure>
</li>
<li><p>print</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>打印i变量当前的值</div><div class="line">(gdb) p(rint) i</div><div class="line"><span class="meta"></span></div><div class="line">#寄存器的值</div><div class="line">(gdb) p $pc</div></pre></td></tr></table></figure>
</li>
<li><p>display</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>调试过程中每一步都回显一次</div><div class="line">(gdb) display /3i $pc</div><div class="line">(gdb) undisplay &lt;dnums...&gt;</div><div class="line">(gdb) info display</div></pre></td></tr></table></figure>
</li>
<li><p>运行中的进程</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(gdb) attach PID</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>函数名字</strong></p>
<p>列出函数原型以及不带调试信息的函数，命令也支持正则表达式<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">(gdb) info function</div><div class="line">All defined functions:</div><div class="line"></div><div class="line">Non-debugging symbols:</div><div class="line">0x00000000004003d8  _init</div><div class="line">0x0000000000400410  printf@plt</div><div class="line">0x0000000000400420  __libc_start_main@plt</div><div class="line">0x0000000000400430  __isoc99_scanf@plt</div><div class="line">0x0000000000400450  _start</div><div class="line">0x0000000000400480  deregister_tm_clones</div><div class="line">0x00000000004004c0  register_tm_clones</div><div class="line">0x0000000000400500  __do_global_dtors_aux</div><div class="line">0x0000000000400520  frame_dummy</div><div class="line">0x0000000000400550  shuru</div><div class="line">0x00000000004005b0  main</div><div class="line">0x0000000000400680  sort</div><div class="line">0x00000000004007e0  __libc_csu_init</div><div class="line">0x0000000000400850  __libc_csu_fini</div><div class="line">0x0000000000400854  _fini</div><div class="line">(gdb) info function sort</div><div class="line">All functions matching regular expression "sort":</div><div class="line"></div><div class="line">Non-debugging symbols:</div><div class="line">0x0000000000400680  sort</div></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Sort Algorithm]]></title>
      <url>/2017/07/01/SortAlgorithm/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>排序算法按照是否使用使用外部存储分为两类：内部排序和外部排序。其中内部排序是数据记录在内存中进行排序，外部排序由于数据量较大超过内存到允许大小，因此在排序到过程中需要访问外存。</p>
<p><img src="/pictures/SortAlgorithm/1.png" alt=""></p>
<p>对数据量较大到数据进行排序，应该考虑吧使用时间复杂度为O(nlog2n)的排序方法：<em>堆排序、快速排序以及归并排序</em>。</p>
<p><strong>快速排序</strong>是目前基于比较的内部排序算法中最好的。在待排序的关键字是随机分布时，这种排序算法的效率是最高的。</p>
<h2 id="插入排序-直接插入排序（Straight-Insertion-Sort）"><a href="#插入排序-直接插入排序（Straight-Insertion-Sort）" class="headerlink" title="插入排序-直接插入排序（Straight Insertion Sort）"></a>插入排序-直接插入排序（Straight Insertion Sort）</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>将一个元素插入到一个有序元素序列中，得到一个长度+1的新的有序元素序列。即，将待排序序列的第一个元素看成一个有序的序列，从第二个元素开始依次插入，每次都要保证序列的有序。<br><img src="/pictures/SortAlgorithm/2.png" alt=""></p>
<p>如果插入到元素和有序序列中到某一元素相等，则插入在该元素的后面，两个相等到元素在排序到过程中顺序是不会被打乱的。因此，直接插入排序是<strong>稳定的</strong>。</p>
<h3 id="算法实现（java）"><a href="#算法实现（java）" class="headerlink" title="算法实现（java）"></a>算法实现（java）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">StraightInsertionSort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> n = a.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</div><div class="line">      <span class="keyword">int</span> tmp = a[i];</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++ ) &#123;</div><div class="line">        <span class="keyword">if</span> (a[i] &gt;= a[j]) &#123;</div><div class="line">          <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> tmpind = j;</div><div class="line">        <span class="keyword">while</span> (j &lt; i) &#123;</div><div class="line">            a[i] = a[--i];</div><div class="line">        &#125;</div><div class="line">        a[tmpind] = tmp;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p>空间复杂度O(1)。最好时间复杂度O(n)，最坏时间复杂度O(n^2)，平均时间复杂度为O(n^2)。最好情况下（已有序），比较次数n-1，移动次数0，最坏情况，比较次数O(n^2)，移动次数O(n^2)</p>
<p>适合少量数据的排序，或者数据基本已经有序的情况。</p>
<h2 id="插入排序-希尔排序（Shell-Sort）"><a href="#插入排序-希尔排序（Shell-Sort）" class="headerlink" title="插入排序-希尔排序（Shell Sort）"></a>插入排序-希尔排序（Shell Sort）</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>将待排元素序列分割成若干个子序列（由相隔某个增量的元素组成），分别进行插入排序，</p>
<h2 id="选择排序—简单选择排序（Simple-Selection-Sort）"><a href="#选择排序—简单选择排序（Simple-Selection-Sort）" class="headerlink" title="选择排序—简单选择排序（Simple Selection Sort）"></a>选择排序—简单选择排序（Simple Selection Sort）</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>在待排序的数组中选择最小的一个数与序列的第一个数进行交换，直到序列中所有到元素都有序。<br><img src="/pictures/SortAlgorithm/4.png" alt=""></p>
<h3 id="算法实现（java）-1"><a href="#算法实现（java）-1" class="headerlink" title="算法实现（java）"></a>算法实现（java）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SimpleSelectionSort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> n = a.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n-<span class="number">1</span> ;i++ ) &#123;</div><div class="line">      <span class="keyword">int</span> minidx = i;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; n ;j++ ) &#123;</div><div class="line">        <span class="keyword">if</span> (a[j] &lt; a[minidx]) &#123;</div><div class="line">          minidx = j;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">int</span> tmp = a[i];</div><div class="line">      a[i] = a[minidx];</div><div class="line">      a[minidx] = tmp;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="效率-1"><a href="#效率-1" class="headerlink" title="效率"></a>效率</h3><p>1、空间复杂度O(1)，最好/最坏/平均时间复杂度都是O(n^2)，比较次数O(n^2)，移动次数O(n)。</p>
<p>2、<strong>选择排序是不稳定的排序方法</strong>（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。</p>
<h2 id="选择排序—堆排序（Heap-Sort）"><a href="#选择排序—堆排序（Heap-Sort）" class="headerlink" title="选择排序—堆排序（Heap Sort）"></a>选择排序—堆排序（Heap Sort）</h2><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><p>堆分为小根堆和大根堆，是完全二叉树。大根堆要求每个节点的值都不大于其父节点的值，即最大值一定在堆顶。</p>
<ul>
<li>将n个待排序元素建成新堆</li>
<li>输出堆顶元素后，将剩余n-1个元素进行调整，使其成为一个新的堆</li>
</ul>
<p><img src="/pictures/SortAlgorithm/5.png" alt=""></p>
<h3 id="算法实现（java）-2"><a href="#算法实现（java）-2" class="headerlink" title="算法实现（java）"></a>算法实现（java）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HeapAjust</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> s,<span class="keyword">int</span> length)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> minchild = <span class="number">2</span>*s + <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (minchild+<span class="number">1</span> &lt; length &amp;&amp; a[minchild] &gt; a[minchild+<span class="number">1</span>]) &#123;</div><div class="line">      minchild++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(minchild &lt; length)&#123;</div><div class="line">      <span class="keyword">if</span> (a[s] &lt; a[minchild]) &#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">int</span> tmp = a[s];</div><div class="line">      a[s] = a[minchild];</div><div class="line">      a[minchild] = tmp;</div><div class="line">      s = minchild;</div><div class="line">      minchild = <span class="number">2</span>*s + <span class="number">1</span>;</div><div class="line">      <span class="keyword">if</span> (minchild+<span class="number">1</span> &lt; length &amp;&amp; a[minchild] &gt; a[minchild+<span class="number">1</span>]) &#123;</div><div class="line">        minchild++;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreatNewHeap</span><span class="params">(<span class="keyword">int</span> [] a)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> n = a.length;</div><div class="line">    <span class="keyword">int</span> s = n/<span class="number">2</span> - <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &gt;= <span class="number">0</span> ;i--) &#123;</div><div class="line">        HeapAjust(a,i,n);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</div><div class="line">    CreatNewHeap(a);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length-<span class="number">1</span>; i++) &#123;</div><div class="line">      <span class="keyword">int</span> n = a.length - i -<span class="number">1</span>;</div><div class="line">      <span class="keyword">int</span> tmp = a[<span class="number">0</span>];</div><div class="line">      a[<span class="number">0</span>] = a[n];</div><div class="line">      a[n] = tmp;</div><div class="line">      HeapAjust(a,<span class="number">0</span>,n-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="效率-2"><a href="#效率-2" class="headerlink" title="效率"></a>效率</h3><p>1、空间复杂度O(1)，平均时间复杂度O（nlogn）,依次堆调整O(logn)——即堆的高度。由于建初始堆所需的比较次数较多，所以堆排序不适宜于记录数量较少的情况。</p>
<p>2、堆排序是不稳定的。</p>
<h2 id="交换排序—冒泡排序（Bubble-Sort）"><a href="#交换排序—冒泡排序（Bubble-Sort）" class="headerlink" title="交换排序—冒泡排序（Bubble Sort）"></a>交换排序—冒泡排序（Bubble Sort）</h2><h3 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h3><p>比较相邻的元素，如果前者比后者大，就交换他们两个，对从前往后对每一对相邻元素作同样的工作，这样一趟冒泡后，最后的元素就是最大的数。这样每一趟冒泡确定一个元素的位置，n趟后数组即有序。同样也可以从后往前冒泡，依次确定最小值。</p>
<p><img src="/pictures/SortAlgorithm/6.png" alt=""></p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> n = a.length;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n-<span class="number">1</span>; i++) &#123;</div><div class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = n-<span class="number">1</span>; j &gt; i; j--) &#123;</div><div class="line">      <span class="keyword">if</span> (a[j] &lt; a[j-<span class="number">1</span>]) &#123;</div><div class="line">        <span class="keyword">int</span> tmp = a[j-<span class="number">1</span>];</div><div class="line">        a[j-<span class="number">1</span>] = a[j];</div><div class="line">        a[j] = tmp;</div><div class="line">        flag = <span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="效率-3"><a href="#效率-3" class="headerlink" title="效率"></a>效率</h3><p>1、空间复杂度O(1)，最好时间复杂度O(n)，最坏时间复杂度O(n^2)，平均时间复杂度O(n^2)。</p>
<p>2、<strong>冒泡排序时稳定的</strong>。</p>
<h2 id="交换排序—快速排序（Quick-Sort）"><a href="#交换排序—快速排序（Quick-Sort）" class="headerlink" title="交换排序—快速排序（Quick Sort）"></a>交换排序—快速排序（Quick Sort）</h2><h3 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h3><p>1）选择一个基准元素,通常选择第一个元素或者最后一个元素,</p>
<p>2）通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。</p>
<p>3）此时基准元素在其排好序后的正确位置</p>
<p>4）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。</p>
<p>快速排序的示例：</p>
<p>（a）一趟排序的过程：</p>
<p><img src="/pictures/SortAlgorithm/7.png" alt=""></p>
<p>（b）排序的全过程</p>
<p><img src="/pictures/SortAlgorithm/8.png" alt=""></p>
<h3 id="算法实现（java）-3"><a href="#算法实现（java）-3" class="headerlink" title="算法实现（java）"></a>算法实现（java）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> tmp = a[i];</div><div class="line">  a[i] = a[j];</div><div class="line">  a[j] = tmp;</div><div class="line">&#125;</div><div class="line"><span class="comment">//快速排序</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> privotKey = a[low];</div><div class="line">  <span class="keyword">while</span> (low &lt; high) &#123;</div><div class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; a[high] &gt; privotKey)&#123;</div><div class="line">      high--;</div><div class="line">    &#125;</div><div class="line">    swap(a,low,high);</div><div class="line">    <span class="keyword">while</span> (low &lt; high &amp;&amp; a[low] &lt; privotKey) &#123;</div><div class="line">      low++;</div><div class="line">    &#125;</div><div class="line">    swap(a,low,high);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> low;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span> (low &lt; high) &#123;</div><div class="line">    <span class="keyword">int</span> pos = Partition(a,low,high);</div><div class="line">    QuickSort(a,low,pos-<span class="number">1</span>);</div><div class="line">    QuickSort(a,pos+<span class="number">1</span>,high);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="效率-4"><a href="#效率-4" class="headerlink" title="效率"></a>效率</h3><p>1、最好空间复杂度O(log(n))，最坏空间复杂度O(n），平均空间复杂度O(logn)；最好时间复杂度O(nlogn)，最坏时间复杂度O(n^2)，平均时间复杂度O(nlogn)。</p>
<p>2、<strong>快速排序时不稳定的</strong>。</p>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>在最坏的情况下，每次划分都将n个元素划分为n-1个元素和1个元素，我们可以通过采取措施尽量较少这种不对称划分来优化算法。例如，我们在选取划分元素时，不是选取特定位置的元素，而是采取随机选取的方式或者随机取三个元素并选定其中值进行划分。</p>
<h2 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h2><h3 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="基本思路"></a>基本思路</h3><p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p>
<h3 id="算法实现（java）-4"><a href="#算法实现（java）-4" class="headerlink" title="算法实现（java）"></a>算法实现（java）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//归并排序</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> start,<span class="keyword">int</span> mid1,<span class="keyword">int</span> mid2,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[end-start+<span class="number">1</span>];</div><div class="line">  <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> starttmp = start;</div><div class="line">  <span class="keyword">while</span>(start &lt;= mid1 &amp;&amp; mid2 &lt;= end)&#123;</div><div class="line">    <span class="keyword">if</span>(a[start] &lt; a[mid2])&#123;</div><div class="line">      tmp[index++] = a[start++];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      tmp[index++] = a[mid2++];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (start &gt; mid1) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid2; i&lt;= end ;i++ ) &#123;</div><div class="line">      tmp[index++] = a[i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i&lt;= mid1 ;i++ ) &#123;</div><div class="line">      tmp[index++] = a[i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  index = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = starttmp;i &lt;= end;i++ ) &#123;</div><div class="line">    a[i] = tmp[index++];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span> (start &lt; end)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</div><div class="line">    MergeSort(a,start,mid);</div><div class="line">    MergeSort(a,mid+<span class="number">1</span>,end);</div><div class="line">    merge(a,start,mid,mid+<span class="number">1</span>,end);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="效率-5"><a href="#效率-5" class="headerlink" title="效率"></a>效率</h3><p>时间复杂度O(nlogn)，空间复杂度O(n)</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>(1)<strong>平方阶(O(n^2))排序</strong></p>
<p>各类简单排序:直接插入、直接选择和冒泡排序；</p>
<p>(2)<strong>线性对数阶(O(nlog2n))排序</strong></p>
<p>快速排序、堆排序和归并排序；</p>
<p>(3)<strong>O(n1+§))排序,§是介于0和1之间的常数</strong></p>
<p>希尔排序</p>
<p>(4)<strong>线性阶(O(n))排序</strong></p>
<p>基数排序，此外还有桶、箱排序。</p>
<p><em>说明：</em></p>
<p>当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至O（n）；</p>
<p>而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O（n2）；</p>
<p>原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。</p>
<h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>排序算法的稳定性:若待排序的序列中，<strong>存在多个具有相同关键字的记录</strong>，经过排序， 这些记录的相对次序保持不变，则称该算法是稳定的；若经排序后，记录的相对 次序发生了改变，则称该算法是不稳定的。</p>
<p><strong>稳定性的好处</strong>:排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。另外，如果排序算法稳定，可以避免多余的比较；</p>
<p><strong>稳定的排序算法</strong>：冒泡排序、插入排序、归并排序和基数排序</p>
<p><strong>不是稳定的排序算法</strong>：选择排序、快速排序、希尔排序、堆排序</p>
<h3 id="选择排序算法准则"><a href="#选择排序算法准则" class="headerlink" title="选择排序算法准则"></a>选择排序算法准则</h3><p>每种排序算法都各有优缺点。因此，在实用时需根据不同情况适当选用，甚至可以将多种方法结合起来使用。</p>
<p>选择排序算法的依据</p>
<p>影响排序的因素有很多，平均时间复杂度低的算法并不一定就是最优的。相反，有时平均时间复杂度高的算法可能更适合某些特殊情况。同时，选择算法时还得考虑它的可读性，以利于软件的维护。一般而言，需要考虑的因素有以下四点：</p>
<ul>
<li><p>待排序的记录数目n的大小；</p>
</li>
<li><p>记录本身数据量的大小，也就是记录中除关键字外的其他信息量的大小；</p>
</li>
<li><p>关键字的结构及其分布情况；</p>
</li>
<li><p>对排序稳定性的要求。</p>
</li>
</ul>
<p>设待排序元素的个数为n.</p>
<p>1）当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。</p>
<p>   快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；</p>
<p>   堆排序 ：  如果内存空间允许且要求稳定性的，</p>
<p>   归并排序：它有一定数量的数据移动，所以我们可能过与插入排序组合，先获得一定长度的序列，然后再合并，在效率上将有所提高。</p>
<p>2）当n较大，内存空间允许，且要求稳定性 =》归并排序</p>
<p>3）当n较小，可采用直接插入或直接选择排序。</p>
<p>直接插入排序：当元素分布有序，直接插入排序将大大减少比较次数和移动记录的次数。</p>
<p>直接选择排序 ：元素分布有序，如果不要求稳定性，选择直接选择排序</p>
<p>5）一般不使用或不直接使用传统的冒泡排序。</p>
<p>6）基数排序<br>它是一种稳定的排序算法，但有一定的局限性：</p>
<ul>
<li><p>关键字可分解。</p>
</li>
<li><p>记录的关键字位数较少，如果密集更好</p>
</li>
<li><p>如果是数字时，最好是无符号的，否则将增加相应的映射复杂度，可先将其正负分开排序。</p>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
